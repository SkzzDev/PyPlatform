import mathclass Physics:    dtf = 0    max_speed = 108    jump_velocity = 4.2    gravity = 10.5    move_speed = {        'ground': 25.2,        'air': 12    }    air_deceleration = 1.025    def __init__(self, game):        self.game = game    def check_collision(self):        self.game.player.collision_ground = None        self.game.player.collision_state = False        for ground in self.game.current_map.grounds.ground_list:            if self.game.player.x + self.game.player.w + 1 >= ground.rect.x and self.game.player.x - 1 <= ground.rect.x + ground.rect.w:                if self.game.player.y + self.game.player.h + 1 >= ground.rect.y and self.game.player.y - 1 <= ground.rect.y + ground.rect.h:                    self.game.player.collision_state = True                    self.game.player.collision_ground = ground                    self.calculate_collision(ground)        if not self.game.player.collision_state:            self.game.player.on_the_ground = False        self.game.player.collision_state = False    @staticmethod    def infinite_test(value):        test = abs(value)        if test == 0:            test = math.inf        return test    def calculate_collision(self, ground):        if self.game.player.px + self.game.player.w < ground.rect.x: # Left            timex = abs(ground.rect.x - (self.game.player.px + self.game.player.w + 1)) / self.infinite_test(self.game.player.pvx)            if self.game.player.py + self.game.player.h < ground.rect.y: # Top                timey = abs(ground.rect.x - (self.game.player.py + self.game.player.h + 1)) / self.infinite_test(self.game.player.pvy)                if timex < timey:                    self.game.player.vy = -self.game.player.vy * ground.type.restitution                    self.game.player.y = ground.rect.y - self.game.player.h - 1                    self.game.player.on_the_ground = True                    self.game.player.can_jump = True                else:                    self.game.player.vx = -self.game.player.vx * ground.type.restitution                    self.game.player.x = ground.rect.x - self.game.player.h - 1            elif self.game.player.py > ground.rect.y + ground.rect.h: # Bottom                timey = abs((ground.rect.x + ground.rect.w) - self.game.player.py) / self.infinite_test(self.game.player.pvy)                if timex < timey:                    self.game.player.vy = -self.game.player.vy * ground.type.restitution                    self.game.player.y = ground.rect.y + ground.rect.h + 1                else:                    self.game.player.vx = -self.game.player.vx * ground.type.restitution                    self.game.player.x = ground.rect.x - self.game.player.w - 1            else: # player était déjà compris dans l'interval y                self.game.player.vx = -self.game.player.vx * ground.type.restitution                self.game.player.x = ground.rect.x - self.game.player.w - 1        elif self.game.player.px > ground.rect.x + ground.rect.w: # Right            timex = abs((ground.rect.x + ground.rect.w) - self.game.player.px + 1) / self.infinite_test(self.game.player.pvx)            if self.game.player.py + self.game.player.h < ground.rect.y: # Top                timey = abs(ground.rect.x - (self.game.player.py + self.game.player.h + 1)) / self.infinite_test(self.game.player.pvy)                if timex < timey:                    self.game.player.vy = -self.game.player.vy * ground.type.restitution                    self.game.player.y = ground.rect.y - self.game.player.h - 1                    self.game.player.on_the_ground = True                    self.game.player.can_jump = True                else:                    self.game.player.vx = -self.game.player.vx * ground.type.restitution                    self.game.player.x = ground.rect.x + ground.rect.w + 1            elif self.game.player.py > ground.rect.y + ground.rect.h: # Bottom                timey = abs((ground.rect.x + ground.rect.w) - self.game.player.py) / self.infinite_test(self.game.player.pvy)                if timex < timey:                    self.game.player.vy = -self.game.player.vy * ground.type.restitution                    self.game.player.y = ground.rect.y + ground.rect.h + 1                else:                    self.game.player.vx = -self.game.player.vx * ground.type.restitution                    self.game.player.x = ground.rect.x + ground.rect.w + 1            else:                self.game.player.vx = -self.game.player.vx * ground.type.restitution                self.game.player.x = ground.rect.x + ground.rect.w + 1        else: # player était déjà compris dans l'interval x            self.game.player.vy = -self.game.player.vy * ground.type.restitution            if self.game.player.py + self.game.player.h < ground.rect.y: # Top                self.game.player.y = ground.rect.y - self.game.player.h - 1                self.game.player.on_the_ground = True                self.game.player.can_jump = True            else: # Bottom                self.game.player.y = ground.rect.y + ground.rect.h + 1